\chapter{Instrukcje Maszyny}
\thispagestyle{chapterBeginStyle}

\iffalse
\section{Opis technologii}

Należy tutaj zamieścić krótki opis (z referencjami) do technologii użytych przy implementacji systemu.

{\color{dgray}
Do implementacji systemu użyto języka JAVA w wersji \ldots, szczegółowy opis można znaleźć w \cite{Java}. Interfejs zaprojektowano w oparciu o HTML5 i CSS3 \cite{HTML-CSS}.
}

\section{Omówienie kodów źródłowych}

{\color{dgray}
Kod źródłowy~\ref{ws} przedstawia opisy poszczególnych metod interfejsu: \texttt{WSPodmiotRejestracjaIF}. Kompletne
kody źródłowe znajdują się na płycie CD dołączonej do niniejszej pracy w katalogu \texttt{Kody} (patrz Dodatek~\ref{plytaCD}).
}

\begin{small}
\begin{lstlisting}[language=Java, frame=lines, numberstyle=\tiny, stepnumber=5, caption=Interfejs usługi Web Service: \texttt{WSPodmiotRejestracjaIF}\label{ws}., firstnumber=1]
package erejestracja.podmiot;
import java.rmi.RemoteException;
// Interfejs web serwisu dotyczącego obsługi podmiotów i rejestracji.
public interface WSPodmiotRejestracjaIF extends java.rmi.Remote{
// Pokazuje informacje o danym podmiocie.
// parametr: nrPeselRegon - numer PESEL podmiotu lub numer REGON firmy.
// return: Podmiot - obiekt transportowy: informacje o danym podmiocie.
public Podmiot pokazPodmiot(long nrPeselRegon) throws RemoteException;
// Dodaje nowy podmiot.
// parametr: nowyPodmiot - obiekt transportowy: informacje o nowym podmiocie.
// return: true - jeśli podmiot dodano, false - jeśli nie dodano.
public boolean dodajPodmiot(Podmiot nowyPodmiot) throws RemoteException;
// Usuwa dany podmiot.
// parametr: nrPeselRegon - numer PESEL osoby fizycznej lub numer REGON firmy.
// return: true - jeśli podmiot usunięto, false - jeśli nie usunięto.
public boolean usunPodmiot(long nrPeselRegon) throws RemoteException;
// Modyfikuje dany podmiot.
// parametr: podmiot - obiekt transportowy: informacje o modyfikowanym podmiocie.
// return: true - jeśli podmiot zmodyfikowano, false - jeśli nie zmodyfikowano.
public boolean modyfikujPodmiot(Podmiot podmiot) throws RemoteException;
// Pokazuje zarejestrowane podmioty na dany dowód rejestracyjny.
// parametr: nrDowoduRejestracyjnego - numer dowodu rejestracyjnego.
// return: PodmiotRejestracja[] - tablica obiektów transportowych: informacje o
// wszystkich zarejestrowanych podmiotach.
public PodmiotRejestracja[] pokazZarejestrowanePodmioty(
String nrDowoduRejestracyjnego) throws RemoteException;
// Nowa rejestracja podmiotu na dany dowód rejestracyjny.
// parametr: nrDowoduRejestracyjnego - numer dowodu rejestracyjnego.
// parametr: nrPeselRegon - numer PESEL podmiotu lub numer REGON firmy.
// parametr: czyWlasciciel - czy dany podmiot jest właścicielem pojazdu.
// return: true - jeśli zarejestrowano podmiot, false - jeśli nie zarejestrowano.
public boolean zarejestrujNowyPodmiot(String nrDowoduRejestracyjnego,
long nrPeselRegon, boolean czyWlasciciel) throws RemoteException;
// Usuwa wiązanie pomiędzy danym podmiotem, a dowodem rejestracyjnym.
// parametr: nrDowoduRejestracyjnego - numer dowodu rejestracyjnego.
// parametr: nrPeselRegon - numer PESEL podmiotu lub numer REGON firmy.
// return: true - jeśli podmiot wyrejestrowano, false - jeśli nie wyrejestrowano.
public boolean wyrejestrujPodmiot(String nrDowoduRejestracyjnego,
long nrPeselRegon) throws RemoteException;
\end{lstlisting} 
\end{small}

{\color{dgray}
Kod źródłowy~\ref{req} przedstawia procedurę przetwarzającą żądanie. Hasz utrwalany \verb|%granulacja| wykorzystywany jest do komunikacji międzyprocesowej.
}

\begin{small}
\begin{lstlisting}[language=perl, frame=lines, caption=Przetwarzanie żądania - procedura \texttt{process\_req()}\label{req}., firstnumber=86]
sub process_req(){	
  my($r) = @_;
  $wyn = "";
  if ($r=~/get/i) {
	@reqest = split(" ",$r);
	$zad = $reqest[0];
	$ts1 = $reqest[1];
	$ts2 = $reqest[2];
	@date1 = split(/\D/,$ts1);
	@date2 = split(/\D/,$ts2);
	print "odebralem: $r"; 
	$wyn = $wyn."zadanie: $zad\n";
	$wyn = $wyn."czas_od: "."$date1[0]"."-"."$date1[1]"."-"."$date1[2]"."_"."$date1[3]".":"."$date1[4]".":"."$date1[5]"."\n";
	$wyn = $wyn."czas_do: "."$date2[0]"."-"."$date2[1]"."-"."$date2[2]"."_"."$date2[3]".":"."$date2[4]".":"."$date2[5]"."\n";		
	$wyn = $wyn.&sym_sens($ts1,$ts2);
	return $wyn;
  }
  if ($r=~/set gt/i) {
	@reqest = split(" ",$r);
	$zad = $reqest[0];
	$ts1 = $reqest[1];
	$ts2 = $reqest[2];
	$gt = $reqest[2];
	dbmopen(%granulacja,"granulacja_baza",0644);
	$granulacja{"gt"}=$gt;
	dbmclose(%granulacja);
	$wyn = "\'GT\' zmienione na: $gt";
  }		
}	
\end{lstlisting} 
\end{small}
\fi

Główna pętla progarmu polega na wywołaniu instrukcji \texttt{CODE[P]} i zwiększeniu \texttt{P} o 1 do momentu dojścia do końca kodu lub w trakcie wykonywania instrkcji zwrócenia $fail$. W pierwszym wypadku pojawia wykonywanie zapytania kończy się powodzeniem i użytkownik zostaje zapytany czy chce kontynuować. Jeśli wybierze "tak" to program wraca do wykonywania zapytania, tak jakby instrukcja zwróciła $fail$. Jeśli wykowana instrukcja zwróci $fail$, to jeśli jest aktywny punkt wyboru to wyknonywana jest operacja nawrotu i zapytanie wykonywane jest dalej. Jeżeli nie ma aktywnego punktu wyboru, to wykonywanie zapytania kończy się z wynikiem $fałsz$.\\
Poniżej opisane są wszystkie obsługiwane instrukcje.

\section{\texttt{put\_structure} $f/n$,\texttt{X}$i$}

Dodaje na koniec sterty komórkę STR i komórkę funktora $f/n$, której adres zawiera. Następnie kopiuje tą komórkę STR do rejestru o adresie \texttt{X}$i$.

\section{\texttt{set\_variable} \texttt{X}$i$}

Dodaje na koniec sterty nieprzypisaną komórkę REF, a następnie umieszcza w rejestrze \texttt{X}$i$ komórkę REF z jej adresem.

\section{\texttt{set\_value} \texttt{X}$i$}

Dodaje na koniec sterty komórkę będącą kopią komórki z rejestru \texttt{X}$i$.

\section{\texttt{get\_structure} $f/n$,\texttt{X}$i$}

Wywołuje $deref(\texttt{X}i)$ i jeżeli otrzymany adres pokazuje na nieprzypisaną komórkę, to dodaje na koniec sterty komórkę STR i komórkę funktora $f/n$, której adres zawiera. Następnie wywołuje $bind(deref(\texttt{X}i),\texttt{H})$ i ustawia tryb maszyny na $write$ i adres \texttt{S} na koniec sterty. W przeciwnym wypadku jeśli $deref(\texttt{X}i)$ pokazuje na komórkę STR z adresem $addr$, to ustawia \texttt{S} na $addr+1$ i tryb maszyny na $read$.

\section{\texttt{unify\_variable} \texttt{X}$i$}

Jeśli maszyna jest w trybie $read$ to kopiuje komórkę z adresu \texttt{S} do rejestru \texttt{X}$i$.\\
Jeśli maszyna jest w trybie $write$ to dodaje na koniec stery nieprzypisaną komórkę i kopiuje ją do rejestru \texttt{X}$i$.

\section{\texttt{unify\_value} \texttt{X}$i$}

Jeśli maszyna jest w trybie $read$ to wywołuje $unify(\texttt{X}i, \texttt{S})$.\\
Jeśli maszyna jest w trybie $write$ to kopiuje komórkę z rejestru \texttt{X}$i$ na koniec sterty.

\section{\texttt{put\_variable} \texttt{X}$i$ \texttt{A}$j$}

Dodaje na koniec sterty nieprzypisaną komórkę, a następnie kopiuje ją do rejestrów \texttt{X}$i$ i \texttt{A}$j$.

\section{\texttt{put\_value} \texttt{X}$i$ \texttt{A}$j$}

Kopiuje komórkę z rejestru \texttt{X}$i$ do rejestru \texttt{A}$j$.

\section{\texttt{get\_variable} \texttt{X}$i$ \texttt{A}$j$}

Kopiuje komórkę z rejestru \texttt{A}$j$ do rejestru \texttt{X}$i$.

\section{\texttt{get\_value} \texttt{X}$i$ \texttt{A}$j$}

Wywołuje $unify(\texttt{X}i, \texttt{A}j)$.

\section{\texttt{call} $label$}

$label$ jest stringiem. Jeśli $label$ jest postaci $*/n$, gdzie $n$ jest liczbą naturalną, to ustawia \texttt{num\_of\_args}$ = n$. Wyszukuje w kodzie wiersza $p$ oznaczonego etykietą $label$. Jeśli takiej etykiety w kodzie nie ma to zwraca \texttt{fail}.
W przeciwnym wypdaku ustawia \texttt{CP}$ = $\texttt{P} i \texttt{P}$ = p - 1$.

\section{\texttt{proceed}}

Ustawia \texttt{P}$ = $\texttt{CP}.

\section{\texttt{allocate} $N$}

Tworzy nowe środowisko $env$ przechowujące obecne \texttt{E} i \texttt{CP} i wstawia je do stosu \texttt{and\_stack} na indeksie $max(B,E)+1$. Następnie przełącza się na środowisko $env$.\\
$N$ jest argumentem oznaczającym ilość rejestrów argumentów, ale ponieważ rejestry są przechowywane w tablicy dynamicznej, w obecnej wersji ten argument nic nie robi.

\section{\texttt{deallocate}}

Ustawia \texttt{P}$ = $\texttt{and\_stack[E].CP}, a następnie przestawia aktywne środowisko na środowisko o indeksie przechowywanym przez obecnie aktywne środowisko.

\section{\texttt{try\_me\_else} $label$}

Tworzy nowy punkt wyboru gdzie \texttt{BP}$ = label$. Następnie ustawia \texttt{B}$ = $\texttt{E} i \texttt{HB}$ = $\texttt{H}.

\section{\texttt{retry\_me\_else} $label$}

Przywraca stan maszyny do stanu bezpośrednio po utworzeniu ostatniego punktu wyboru. Także zamienia etykietę pamiętaną przez aktywny punkt wyboru na $label$. Nie zmienia rejestru \texttt{P}.

\section{\texttt{trust\_me}}

Przywraca stan maszyny do stanu z przed utworzenia ostatniego punktu wyboru, usuwając go. Nie zmienia rejestru \texttt{P}.

\section{Instrukcje specjalne}

Niektóre instrukcje pojawiają się w kodzie generowanym przez samą maszynę przed załadowaniem programu, ale nie powinny być zawierane przez ładowany program.

\subsection{\texttt{write}}

Wypisuje na standardowe wyjście tektową reprezentacje termu na który pokazuje adres $deref($\texttt{A0}$)$. Jeśli otrzymany adres pokazuje na nieprzypisaną komórkę, wyświetlany jest jako \texttt{\_}$mn$, gdzie $m$ oznacza block pamięci w której zanjduje się zmienna: $H$ - sterta, $X$ - rejestry tymczasowe, $A$ - rejestry argumentów, $Y$ - rejestry trwałe. $n$ oznacza indeks w tym bloku pamięci. Jeżeli otrzymany adres pokazuje na komórkę STR, której adres pokazuje na komórkę funtora $f/n$, gdzie $n > 0$ to rekurencyjnie wypisywane są też podtermy.